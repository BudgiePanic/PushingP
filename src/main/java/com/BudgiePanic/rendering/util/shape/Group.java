package com.BudgiePanic.rendering.util.shape;

import static com.BudgiePanic.rendering.util.Tuple.makePoint;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicReference;

import com.BudgiePanic.rendering.util.Tuple;
import com.BudgiePanic.rendering.util.intersect.Intersection;
import com.BudgiePanic.rendering.util.intersect.Ray;
import com.BudgiePanic.rendering.util.matrix.Matrix4;

/**
 * A group is a shape comprised of more shapes.
 * 
 * @author BudgiePanic
 */
public class Group extends BaseShape {
    
    /**
     * A mutable collection of shapes.
     */
    protected final List<Shape> children;

    /**
     * Creates a new empty group with no parent.
     *
     * @param transform
     *   The transform to enter group space.
     */
    public Group(Matrix4 transform) {
        super(transform);
        this.children = new ArrayList<>();
        this.AABB = new AtomicReference<>();
    }

    /**
     * Gets the shapes that are part of this group.
     * @return
     *   The shapes that belong to this group.
     */
    public List<Shape> getShapes() {
        return Collections.unmodifiableList(this.children);
    }
    
    /**
     * Adds the shape to this group and sets the group's parent to 'this'.
     * @param shape
     *   The shape to add to the group.
     */
    public void addShape(Shape shape) {
        this.AABB.set(null);
        this.children.add(shape);
        shape.setParent(this);
    }

    public void removeShape(Shape shape) {
        this.AABB.set(null);
        var removed = this.children.remove(shape);
        if (removed) {
            shape.setParent(null);
        }
    }

    @Override
    protected Optional<List<Intersection>> localIntersect(Ray ray) {
        if (!bounds().intersect(ray)) {
            return Optional.empty();
        }
        List<Intersection> result = null;
        for (var child : children) {
            var intersect = child.intersect(ray);
            if (intersect.isPresent()) {
                if (result == null) result = new ArrayList<>();
                result.addAll(intersect.get());
            }
        }
        if (result != null) result.sort(Comparator.comparing(Intersection::a));
        return Optional.ofNullable(result);
    }

    @Override
    protected Tuple localNormal(Tuple point) { throw new UnsupportedOperationException("Shape group does not support localNormal operation"); }

    protected AtomicReference<BoundingBox> AABB = new AtomicReference<>();

    @Override
    public BoundingBox bounds() {
        // The intention of the atomic reference here is that only one thread will enter this 'if statement' critical section to assign the AABB
        // other threads should wait until the AABB is set before skipping the critical section and returning the AABB generated by the first thread
        // the AABB only needs to be generated once.
        // I don't know if this code actually achieves this goal, Help is needed.
        // Alternative ideas: - regenerate the AABB every time addShape and removeShape are called
        //                    - allow the programmer to manually trigger AABB regeneration when they think it is appropriate
        //                    - use a synchronized block
        if (AABB.getAcquire() == null) {
            BoundingBox box = new BoundingBox(makePoint(), makePoint());
            // the cube has 8 points [000,100,001,101,010,110,011,111]
            for (var shape : this.children) {
                final BoundingBox localAABB = shape.bounds();
                final var aabbMin = localAABB.minimum();
                final var aabbMax = localAABB.maximum();
                final var transform = shape.transform();
                // find the AABB points in 'group space'
                Tuple _000 = transform.multiply(new Tuple(aabbMax.x, aabbMin.y, aabbMin.z)); // MAX MIN 
                Tuple _100 = transform.multiply(aabbMin); // MIN                                MIN MIN
                Tuple _001 = transform.multiply(new Tuple(aabbMax.x, aabbMin.y, aabbMax.z)); // MAX MAX
                Tuple _101 = transform.multiply(new Tuple(aabbMin.x, aabbMin.y, aabbMax.z)); // MIN MAX

                Tuple _010 = transform.multiply(new Tuple(aabbMax.x, aabbMax.y, aabbMin.z)); // MAX MIN
                Tuple _110 = transform.multiply(new Tuple(aabbMin.x, aabbMax.y, aabbMin.z)); // MIN MIN
                Tuple _011 = transform.multiply(aabbMax); // MAX                                MAX MAX
                Tuple _111 = transform.multiply(new Tuple(aabbMin.x, aabbMax.y, aabbMax.z)); // MIN MAX
                var points = List.of(_000, _001, _010, _011, _100, _101, _110, _111);
                // check if we need to grow the AABB extents to contain the points
                for (var point : points) {
                    if (!box.contains(point)) {
                        box = box.grow(point);
                    }
                }
            }
            this.AABB.setRelease(box);
        }
        return AABB.get();
    }

}
